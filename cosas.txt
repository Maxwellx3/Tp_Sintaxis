while resultado == 0:
            X = self.pila.popp()  #desapila

            if X != lex.peso :
                self.nodoActual = self.pila2.popp()  #desapila segunda pila y lo asigna a nodo actual

            if X ==  a[0] == lex.peso:
                resultado = 1 #proceso terminado con exito
            elif X in Terminal: #si X es terminal
                if X == a[0]: #y es el componente lexico leido
                    self.nodoActual.agregarHijo(ar.Nodo(a[1])) #se agrega como hijo al nodo actual
                    a = self.Lexico.siguienteComponenteLexico(self.tablaSimbolos) #y se obtiene el siguiente componente
                else:
                    resultado = -1 #error
            elif X in Variables: #si X es variable
                v = tas.tas(X[0], a[0]) #se obtiene el vector con la variable y el componente correspondiente
                if tas.tVecTASVacio(v): #si esta v vacio
                    print("Error sintactico")
                    resultado = -1 #error
                else:
                    i = 0
                    auxPila = p.Pila() #se crea dos auxiliares pila
                    auxPila2 = p.Pila()
                    while i < len(v) and v[i] != []: #mientras no se pase de rango y no quede vacio
                        self.nodoActual.agregarHijo(ar.Nodo(v[i])) # se agrega el hijo ial arbol
                        nodo = self.nodoActual.getHijos()[-1] #se obtiene su nodo
                        auxPila.push(v[i]) #se apila en la primera pila auxiliar el elemento
                        auxPila2.push(nodo) # se apila en la segunda pila auxiliar el nodo
                        i += 1 #se suma al contador
                    while i >= 0: #mientras sea mayor igual a cero, como un for de i..0
                        aux = auxPila.popp()  #se desapilan en auxiliares las pilas auxiliares
                        aux2 = auxPila2.popp()
                        if aux != None and aux != lex.epsilon :  #no se apila epsilon
                            self.pila.push(aux) # se apilar los auxiliares de forma que quedan apiladas de manera invertida
                        if aux2 != None and aux != lex.epsilon:
                            self.pila2.push(aux2)
                        i -= 1 #se descuenta contador
        return self.arbol #se devuelve el arbol


import pandas as pd
import scanner as sc

# Carga el archivo CSV en un DataFrame
df = pd.read_csv('CSVTAS.csv', header=None)
componente_lexico = df.iloc[0, 1:].tolist()
variable = df.iloc[1:, 0].tolist()

# Crear el diccionario tas_dict
tas_dict = {}

# Iterar sobre las intersecciones de índices y guardar los valores en el diccionario
for var in range(len(variable)):
    for lex in range(1, len(componente_lexico) + 1):
        regla = df.iloc[var + 1, lex]
        tas_dict[(variable[var], componente_lexico[lex - 1])] = regla

# Componente léxico y variable específicos para buscar
componente_lexico_buscar = 'id'
variable_buscar = 'H'
if (variable_buscar, componente_lexico_buscar) in tas_dict:
    regla1= tas_dict[(variable_buscar, componente_lexico_buscar)]
    if regla.isna():
        print('Es vacio')
    else:
        prim_letra= regla1[0]
        print(prim_letra)